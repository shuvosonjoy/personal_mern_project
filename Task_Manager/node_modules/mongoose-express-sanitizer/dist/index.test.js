"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _ = require(".");

var _mongoose = _interopRequireDefault(require("mongoose"));

// String
describe('body schema validator with attributes of type string', function () {
  var taskSchema = new _mongoose["default"].Schema({
    title: {
      type: String,
      minlength: 10,
      required: true
    },
    description: {
      type: String,
      "default": ''
    },
    resume: {
      type: String,
      maxlength: 30
    },
    status: {
      type: String,
      "enum": ['pending', 'in-progress', 'completed']
    },
    priority: {
      type: String,
      "enum": ['low', 'medium', 'high'],
      "default": 'medium'
    },
    notes: {
      type: String,
      required: false
    }
  });

  var Task = _mongoose["default"].model('Task', taskSchema);

  var _Task$schema$tree = Task.schema.tree,
      title = _Task$schema$tree.title,
      description = _Task$schema$tree.description,
      status = _Task$schema$tree.status,
      priority = _Task$schema$tree.priority,
      resume = _Task$schema$tree.resume;
  it('should return without errors when all attributes are valid', function () {
    var bodyRequest = {
      title: 'titleOfTask',
      description: 'description',
      status: 'pending',
      priority: 'low',
      resume: 'resume of task'
    };
    expect(function () {
      return (0, _.body)({
        title: title,
        description: description,
        status: status,
        priority: priority,
        resume: resume
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return an error when the title is not a string', function () {
    var bodyRequest = {
      title: 1,
      description: 'description',
      status: 'pending',
      priority: 'low'
    };
    expect(function () {
      return (0, _.body)({
        title: title,
        description: description,
        status: status,
        priority: priority
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Expected a string, but received \'number\'.'
    });
  });
  it('should return an error when the required title is not sended', function () {
    var bodyRequest = {
      description: 'description',
      status: 'pending',
      priority: 'low'
    };
    expect(function () {
      return (0, _.body)({
        title: title,
        description: description,
        status: status,
        priority: priority
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute title is required.'
    });
  });
  it('should return an error when the title is less than the minlength', function () {
    var bodyRequest = {
      title: 'title',
      description: 'description',
      status: 'pending',
      priority: 'low'
    };
    expect(function () {
      return (0, _.body)({
        title: title,
        description: description,
        status: status,
        priority: priority
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The string length must be at least 10.'
    });
  });
  it('should return an error when the reume is more than the maxlength', function () {
    var bodyRequest = {
      title: 'titleOfTask',
      description: 'description',
      status: 'pending',
      priority: 'low',
      resume: 'resume of task with more than 30 characters'
    };
    expect(function () {
      return (0, _.body)({
        title: title,
        description: description,
        status: status,
        priority: priority,
        resume: resume
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The string length must not exceed 30.'
    });
  });
  it('should return an error when the status is not the accepted values of enum', function () {
    var bodyRequest = {
      title: 'titleOfTask',
      description: 'description',
      status: 'status',
      priority: 'low'
    };
    expect(function () {
      return (0, _.body)({
        title: title,
        description: description,
        status: status,
        priority: priority
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Invalid value. The value must be one of the following: pending, in-progress, completed.'
    });
  });
}); // Number

describe('body schema validator with attributes of type number', function () {
  var productSchema = new _mongoose["default"].Schema({
    price: {
      type: Number,
      required: true,
      min: 0
    },
    quantity: {
      type: Number,
      required: true,
      min: 1
    },
    discount: {
      type: Number,
      "default": 0,
      min: 0,
      max: 100
    },
    rating: {
      type: Number,
      required: true,
      "enum": [1, 2, 3, 4, 5]
    }
  });

  var Product = _mongoose["default"].model('Product', productSchema);

  var _Product$schema$tree = Product.schema.tree,
      price = _Product$schema$tree.price,
      quantity = _Product$schema$tree.quantity,
      discount = _Product$schema$tree.discount,
      rating = _Product$schema$tree.rating;
  it('should return withour error when all attributes are valid', function () {
    var bodyRequest = {
      price: 1,
      quantity: 1,
      discount: 0,
      rating: 1
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        quantity: quantity,
        discount: discount,
        rating: rating
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return an error when the price is not a number', function () {
    var bodyRequest = {
      price: 'price',
      quantity: 1,
      discount: 0,
      rating: 1
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        quantity: quantity,
        discount: discount,
        rating: rating
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Expected a number, but received \'string\'.'
    });
  });
  it('should return an error when the required price is not sended', function () {
    var bodyRequest = {
      quantity: 1,
      discount: 0,
      rating: 1
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        quantity: quantity,
        discount: discount,
        rating: rating
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute price is required.'
    });
  });
  it('should return an error when the price is less than the min', function () {
    var bodyRequest = {
      price: -1,
      quantity: 1,
      discount: 0,
      rating: 1
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        quantity: quantity,
        discount: discount,
        rating: rating
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Value -1 is less than the minimum value setted.'
    });
  });
  it('should return an error when the quantity is not a number', function () {
    var bodyRequest = {
      price: 1,
      quantity: 'quantity',
      discount: 0,
      rating: 1
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        quantity: quantity,
        discount: discount,
        rating: rating
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Expected a number, but received \'string\'.'
    });
  });
  it('should return an error when the required quantity is undefined', function () {
    var bodyRequest = {
      price: 1,
      quantity: undefined,
      discount: 0,
      rating: 1
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        quantity: quantity,
        discount: discount,
        rating: rating
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute quantity is required.'
    });
  });
  it('should return an error when the required quantity is null', function () {
    var bodyRequest = {
      price: 1,
      quantity: null,
      discount: 0,
      rating: 1
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        quantity: quantity,
        discount: discount,
        rating: rating
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute quantity is required.'
    });
  });
}); // Boolean

describe('body schema validator with attributes of type boolean', function () {
  var inscriptionSchema = new _mongoose["default"].Schema({
    isAvailable: {
      type: Boolean,
      required: true
    },
    isFree: {
      type: Boolean
    }
  });

  var Inscription = _mongoose["default"].model('Inscription', inscriptionSchema);

  var _Inscription$schema$t = Inscription.schema.tree,
      isAvailable = _Inscription$schema$t.isAvailable,
      isFree = _Inscription$schema$t.isFree;
  it('should return without error when all attributes are valid', function () {
    var bodyRequest = {
      isAvailable: true,
      isFree: false
    };
    expect(function () {
      return (0, _.body)({
        isAvailable: isAvailable,
        isFree: isFree
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return an error when the required attribute is not sended', function () {
    expect(function () {
      return (0, _.body)({
        isAvailable: isAvailable
      }, {
        body: {}
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute isAvailable is required.'
    });
  });
  it('should return an error when the required attribute is null', function () {
    var bodyRequest = {
      isAvailable: null
    };
    expect(function () {
      return (0, _.body)({
        isAvailable: isAvailable
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute isAvailable is required.'
    });
  });
  it('should return an error when the required attribute is undefined', function () {
    var bodyRequest = {
      isAvailable: undefined
    };
    expect(function () {
      return (0, _.body)({
        isAvailable: isAvailable
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute isAvailable is required.'
    });
  });
  it('should return an error when the attribute is not a boolean', function () {
    var bodyRequest = {
      isAvailable: 'true'
    };
    expect(function () {
      return (0, _.body)({
        isAvailable: isAvailable
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Expected a boolean, but received \'string\'.'
    });
  });
}); // Date

describe('body schema validator with attributes of type date', function () {
  var userSchema = new _mongoose["default"].Schema({
    birthDate: {
      type: Date,
      required: true
    },
    lastLogin: {
      type: Date,
      "default": Date.now
    }
  });

  var User = _mongoose["default"].model('User', userSchema);

  var _User$schema$tree = User.schema.tree,
      birthDate = _User$schema$tree.birthDate,
      lastLogin = _User$schema$tree.lastLogin;
  it('should return without error when all attributes are valid', function () {
    var bodyRequest = {
      birthDate: new Date(),
      lastLogin: new Date()
    };
    expect(function () {
      return (0, _.body)({
        birthDate: birthDate,
        lastLogin: lastLogin
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return an error when the required attribute is not sended', function () {
    expect(function () {
      return (0, _.body)({
        birthDate: birthDate
      }, {
        body: {}
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute birthDate is required.'
    });
  });
  it('should return an error when the required attribute is null', function () {
    var bodyRequest = {
      birthDate: null
    };
    expect(function () {
      return (0, _.body)({
        birthDate: birthDate
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute birthDate is required.'
    });
  });
  it('should return an error when the required attribute is undefined', function () {
    var bodyRequest = {
      birthDate: undefined
    };
    expect(function () {
      return (0, _.body)({
        birthDate: birthDate
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute birthDate is required.'
    });
  });
  it('should return an error when the attribute is not a date', function () {
    var bodyRequest = {
      birthDate: 'birthDate'
    };
    expect(function () {
      return (0, _.body)({
        birthDate: birthDate
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Expected a valid Date object, but received \'string\'.'
    });
  });
}); // Array

describe('body schema validator with attributes of type array', function () {
  var socialNetworkSchema = new _mongoose["default"].Schema({
    hobbies: {
      type: Array,
      required: true
    },
    friends: {
      type: Array,
      "enum": ['friend'],
      of: String
    }
  });

  var SocialNetwork = _mongoose["default"].model('socialNetwork', socialNetworkSchema);

  var _SocialNetwork$schema = SocialNetwork.schema.tree,
      hobbies = _SocialNetwork$schema.hobbies,
      friends = _SocialNetwork$schema.friends;
  it('should return without error when all attributes are valid', function () {
    var bodyRequest = {
      hobbies: ['hobby'],
      friends: ['friend']
    };
    expect(function () {
      return (0, _.body)({
        hobbies: hobbies,
        friends: friends
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when the attribute is not required and null is sended', function () {
    var bodyRequest = {
      friends: null
    };
    expect(function () {
      return (0, _.body)({
        friends: friends
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when the attribute is not required and undefined is sended', function () {
    var bodyRequest = {
      friends: undefined
    };
    expect(function () {
      return (0, _.body)({
        friends: friends
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return an error when Array enum attribute is not valid', function () {
    var bodyRequest = {
      hobbies: ['hobby'],
      friends: ['joao', 'maria']
    };
    expect(function () {
      return (0, _.body)({
        hobbies: hobbies,
        friends: friends
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Invalid value in the array. The values must be one of friend.'
    });
  });
  it('should return an error when the required attribute is not sended', function () {
    expect(function () {
      return (0, _.body)({
        hobbies: hobbies
      }, {
        body: {}
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute hobbies is required.'
    });
  });
  it('should return an error when the required attribute is null', function () {
    var bodyRequest = {
      hobbies: null
    };
    expect(function () {
      return (0, _.body)({
        hobbies: hobbies
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute hobbies is required.'
    });
  });
  it('should return an error when the required attribute is undefined', function () {
    var bodyRequest = {
      hobbies: undefined
    };
    expect(function () {
      return (0, _.body)({
        hobbies: hobbies
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'The attribute hobbies is required.'
    });
  });
}); // Object

describe('body schema validator with attributes of type object', function () {
  var animalSchema = new _mongoose["default"].Schema({
    species: String,
    physicalCharacteristics: {
      size: {
        type: String
      }
    },
    behavior: {
      diet: {
        type: String,
        "enum": ['carnivore', 'herbivore', 'omnivore']
      },
      communication: {
        verbal: {
          type: Boolean
        },
        nonVerbal: {
          type: Boolean
        }
      }
    }
  });

  var Animal = _mongoose["default"].model('Animal', animalSchema);

  var _Animal$schema$tree = Animal.schema.tree,
      size = _Animal$schema$tree.size,
      behavior = _Animal$schema$tree.behavior;
  it('should return without error when all attributes of object with children are valid', function () {
    var bodyRequest = {
      size: 'big',
      behavior: {
        diet: 'carnivore',
        communication: {
          verbal: true,
          nonVerbal: false
        }
      }
    };
    expect(function () {
      return (0, _.body)({
        size: size,
        behavior: behavior
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
}); // isDecimal128

describe('body schema validator with attributes of type isDecimal128', function () {
  var carSchema = new _mongoose["default"].Schema({
    price: {
      type: _mongoose["default"].Schema.Types.Decimal128,
      required: true
    },
    discount: {
      type: _mongoose["default"].Schema.Types.Decimal128,
      required: false,
      "enum": [0.1, 0.2, 0.3, 0.4, 0.5]
    },
    tax: {
      type: _mongoose["default"].Schema.Types.Decimal128
    }
  });

  var Car = _mongoose["default"].model('Car', carSchema);

  var _Car$schema$tree = Car.schema.tree,
      price = _Car$schema$tree.price,
      discount = _Car$schema$tree.discount,
      tax = _Car$schema$tree.tax;
  it('should return without error when all attributes are valid', function () {
    var bodyRequest = {
      price: 123.45,
      discount: 0.1,
      tax: 0.2
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        discount: discount,
        tax: tax
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when the attribute is not required and null is sended', function () {
    var bodyRequest = {
      price: 123.45,
      discount: null,
      tax: null
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        discount: discount,
        tax: tax
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when the attribute is not required and undefined is sended', function () {
    var bodyRequest = {
      price: 123.45,
      discount: undefined
    };
    expect(function () {
      return (0, _.body)({
        price: price,
        discount: discount
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return an error when the attribute is not a decimal128', function () {
    var bodyRequest = {
      price: 'price'
    };
    expect(function () {
      return (0, _.body)({
        price: price
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Invalid Decimal128.'
    });
  });
}); // isValidObjectId

describe('body schema validator with attributes of type isValidObjectId', function () {
  var lawSchema = new _mongoose["default"].Schema({
    id: {
      type: _mongoose["default"].Schema.Types.ObjectId,
      required: true
    },
    arincipalArticles: {
      type: _mongoose["default"].Schema.Types.ObjectId,
      required: false
    }
  });

  var Law = _mongoose["default"].model('Law', lawSchema);

  var id = Law.schema.tree.id;
  it('should return without error when all attributes are valid', function () {
    var bodyRequest = {
      id: '5f8a9d9a9d9a9d9a9d9a9d9a'
    };
    expect(function () {
      return (0, _.body)({
        id: id
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
}); // isValidMap

describe('body schema validator with attributes of type isValidMap', function () {
  var employeeSchema = new _mongoose["default"].Schema({
    mapStringMongoose: {
      type: Map,
      of: _mongoose["default"].Schema.Types.String,
      required: true
    },
    mapNumberMongoose: {
      type: Map,
      of: _mongoose["default"].Schema.Types.Number,
      required: true
    },
    mapBooleanMongoose: {
      type: Map,
      of: _mongoose["default"].Schema.Types.Boolean,
      required: true
    },
    mapDateMongoose: {
      type: Map,
      of: _mongoose["default"].Schema.Types.Date,
      required: true
    },
    mapDecimal128Mongoose: {
      type: Map,
      of: _mongoose["default"].Schema.Types.Decimal128,
      required: true
    },
    mapObjectIdMongoose: {
      type: Map,
      of: {
        type: _mongoose["default"].Schema.Types.ObjectId
      },
      required: true
    },
    mapBufferMongoose: {
      type: Map,
      of: Buffer,
      required: true
    }
  });

  var Employee = _mongoose["default"].model('Employee', employeeSchema);

  var _Employee$schema$tree = Employee.schema.tree,
      mapStringMongoose = _Employee$schema$tree.mapStringMongoose,
      mapNumberMongoose = _Employee$schema$tree.mapNumberMongoose,
      mapBooleanMongoose = _Employee$schema$tree.mapBooleanMongoose,
      mapDateMongoose = _Employee$schema$tree.mapDateMongoose,
      mapDecimal128Mongoose = _Employee$schema$tree.mapDecimal128Mongoose,
      mapObjectIdMongoose = _Employee$schema$tree.mapObjectIdMongoose,
      mapBufferMongoose = _Employee$schema$tree.mapBufferMongoose;
  it('should return without error when MAP of String are valid', function () {
    var bodyRequest = {
      mapStringMongoose: ['test', 'test']
    };
    expect(function () {
      return (0, _.body)({
        mapStringMongoose: mapStringMongoose
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when MAP of Number are valid', function () {
    var bodyRequest = {
      mapNumberMongoose: [1, 2]
    };
    expect(function () {
      return (0, _.body)({
        mapNumberMongoose: mapNumberMongoose
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when MAP of Boolean are valid', function () {
    var bodyRequest = {
      mapBooleanMongoose: [true, false]
    };
    expect(function () {
      return (0, _.body)({
        mapBooleanMongoose: mapBooleanMongoose
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when MAP of Date are valid', function () {
    var validDate = new Date();
    var bodyRequest = {
      mapDateMongoose: [validDate, validDate]
    };
    expect(function () {
      return (0, _.body)({
        mapDateMongoose: mapDateMongoose
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when MAP of Decimal128 are valid', function () {
    var bodyRequest = {
      mapDecimal128Mongoose: [123.45, 123.45]
    };
    expect(function () {
      return (0, _.body)({
        mapDecimal128Mongoose: mapDecimal128Mongoose
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when MAP of ObjectId are valid', function () {
    var bodyRequest = {
      mapObjectIdMongoose: ['5f8a9d9a9d9a9d9a9d9a9d9a', '5f8a9d9a9d9a9d9a9d9a9d9a']
    };
    expect(function () {
      return (0, _.body)({
        mapObjectIdMongoose: mapObjectIdMongoose
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return without error when MAP of Buffer are valid', function () {
    var validBuffer = Buffer.from('buffer');
    var bodyRequest = {
      mapBufferMongoose: [validBuffer, validBuffer]
    };
    expect(function () {
      return (0, _.body)({
        mapBufferMongoose: mapBufferMongoose
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
  it('should return an error when the attribute is not a MAP', function () {
    var bodyRequest = {
      mapStringMongoose: 'test'
    };
    expect(function () {
      return (0, _.body)({
        mapStringMongoose: mapStringMongoose
      }, {
        body: bodyRequest
      });
    }).toThrow({
      httpErrorCode: 400,
      message: 'Invalid Map.'
    });
  });
}); // isValidBuffer

describe('body schema validator with attributes of type isValidBuffer', function () {
  var fileSchema = new _mongoose["default"].Schema({
    buffer: {
      type: Buffer,
      required: true
    }
  });

  var File = _mongoose["default"].model('File', fileSchema);

  var buffer = File.schema.tree.buffer;
  it('should return without error when all attributes are valid', function () {
    var bodyRequest = {
      buffer: Buffer.from('buffer')
    };
    expect(function () {
      return (0, _.body)({
        buffer: buffer
      }, {
        body: bodyRequest
      });
    }).not.toThrow();
  });
});